<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JuMPGUI</title>
  <style>
    @font-face {
      font-family: 'JuliaMono';
      /* Uncomment one of the following lines to choose a font weight: */
      /* src: url("https://cdn.jsdelivr.net/gh/cormullion/juliamono-webfonts/JuliaMono-Black.woff2") format('woff2'); */
      src: url("https://cdn.jsdelivr.net/gh/cormullion/juliamono-webfonts/JuliaMono-Light.woff2") format('woff2');
    }
    html, body { margin: 0; padding: 0; height: 100%; }
    body { font-family: 'JuliaMono', monospace; font-size: 10pt; }
    /* Fullscreen canvas */
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    /* Sidebar overlaid on top of the canvas */
    #sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 300px;
      height: 100%;
      background-color: rgba(240,240,240,0.9);
      padding: 10px;
      box-sizing: border-box;
      overflow-y: auto;
      z-index: 10;
      border-right: 1px solid #ccc;
    }
    #sidebar h2 {
      margin-bottom: 5px;
      letter-spacing: -0.5px;
      font-family: sans-serif;
    }
    #sidebar button { margin-top: 10px; padding: 5px 10px; }
    .inequality-item { padding: 4px; cursor: pointer; }
    .inequality-item:hover { background-color: #e0e0ff; }
    .objective-item { padding: 4px; cursor: pointer; }
    .objective-item:hover { background-color: #e0e0ff; }
    #sidebarHandle {
      position: fixed;
      top: 0;
      left: 300px;        /* starts at the sidebar's initial width */
      width: 5px;         /* a slim handle */
      height: 100%;
      cursor: ew-resize;   /* east-west resize cursor */
      z-index: 20;        /* above the sidebar */
      background: rgba(0, 0, 0, 0.1); /* subtle visual cue (optional) */
    }
  </style>
</head>
<body>
  <!-- Overlaid sidebar -->
  <div id="sidebar">
    <h2>Constraints</h2>
    <div id="inequalities"></div>
  
    <!-- Objective section -->
    <h2>Objective</h2>
    <div id="objectiveDisplay">No objective defined.</div>
    <button id="zoomButton">Zoom</button>
    <button id="unzoomButton">Unzoom</button>
    <button id="traceButton">Trace Central Path</button>
    <br><br>
    <h2>Central Path</h2>
    <div id="analyticResult"></div>
    <div style="margin-top:20px; font-size:0.8em;">
      <strong>Usage Tips:</strong><br>
      <strong>Draw</strong>: click to add vertices, click inside when done.<br>
      <strong>Move</strong>: drag vertices to reshape.<br>
      <strong>Add</strong>: double-click an edge to insert a vertex.<br>
      <strong>Red Overlay</strong>: indicates non-convexity, must adjust.<br>
      <strong>Zoom</strong>: fits the polygon in view.<br>
      <strong>Objective</strong>: drag the objective arrow to adjust direction.<br>
      <strong>Press S</strong>: toggle snapping to the grid.
    </div>
  </div>
  
  <!-- Fullscreen canvas -->
  <canvas id="gridCanvas"></canvas>
  
  <script>
    // Get references to elements.
    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const inequalitiesDiv = document.getElementById('inequalities');
    const zoomButton = document.getElementById('zoomButton');
    const unzoomButton = document.getElementById('unzoomButton');
    const traceButton = document.getElementById('traceButton');
    const analyticResultDiv = document.getElementById('analyticResult');
    const objectiveDisplay = document.getElementById('objectiveDisplay');

    // Global drawing variables.
    let centerX, centerY;
    const gridSpacing = 20; // base pixels per grid unit

    // Transformation parameters (in grid units).
    let offset = { x: 0, y: 0 };
    let scaleFactor = 1;

    // Polygon and objective (all coordinates in grid units).
    let vertices = [];
    let currentMouse = null;
    let polygonComplete = false;
    let interiorPoint = null;
    let objectiveVector = null;
    let currentObjective = null;

    // Backend-computed values.
    let computedVertices = [];
    let computedLines = [];

    // Additional flags and undo/redo history.
    let snapToGrid = false;
    let highlightIndex = null;
    let analyticCenter = null;
    let centralPath = [];
    // New flag to indicate if a central path has already been computed.
    let centralPathComputed = false;
    let historyStack = [];
    let redoStack = [];

    // --- Undo/Redo Functions ---
    function saveState() {
      historyStack.push({
        vertices: JSON.parse(JSON.stringify(vertices)),
        objectiveVector: objectiveVector ? { ...objectiveVector } : null
      });
      redoStack = [];
    }
    function undo() {
      if (historyStack.length > 0) {
        const lastState = historyStack.pop();
        redoStack.push({
          vertices: JSON.parse(JSON.stringify(vertices)),
          objectiveVector: objectiveVector ? { ...objectiveVector } : null
        });
        vertices = lastState.vertices;
        objectiveVector = lastState.objectiveVector;
        draw();
        sendPolytope();
      }
    }
    function redo() {
      if (redoStack.length > 0) {
        const nextState = redoStack.pop();
        historyStack.push({
          vertices: JSON.parse(JSON.stringify(vertices)),
          objectiveVector: objectiveVector ? { ...objectiveVector } : null
        });
        vertices = nextState.vertices;
        objectiveVector = nextState.objectiveVector;
        draw();
        sendPolytope();
      }
    }
    window.addEventListener('keydown', function(e) {
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      }
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'z' && e.shiftKey) {
        e.preventDefault();
        redo();
      }
    });
    window.addEventListener('keydown', function(e) {
      if (e.key.toLowerCase() === 's') {
        snapToGrid = !snapToGrid;
        // console.log("Snap to grid:", snapToGrid);
      }
    });

    // --- Helper Functions ---
    function distance(p1, p2) {
      return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
    }
    function pixelDistance(p1, p2) {
      return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
    }
    function computeCentroid(pts) {
      let sumX = 0, sumY = 0;
      pts.forEach(pt => { sumX += pt.x; sumY += pt.y; });
      return { x: sumX / pts.length, y: sumY / pts.length };
    }
    function updateObjectiveDisplay() {
      if (objectiveVector != null) {
        let a = Math.round(objectiveVector.x * 1000) / 1000;
        let b = Math.round(objectiveVector.y * 1000) / 1000;
        let str = a + "x" + (b >= 0 ? " + " + b + "y" : " - " + (-b) + "y");
        objectiveDisplay.classList.add('objective-item');
        objectiveDisplay.innerHTML = str;
      } else {
        objectiveDisplay.classList.remove('objective-item');
        objectiveDisplay.innerHTML = "No objective defined.";
      }
    }

    // --- Zoom/Unzoom ---
    zoomButton.addEventListener('click', function() {
      if (vertices.length > 0) {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        vertices.forEach(v => {
          if (v.x < minX) minX = v.x;
          if (v.x > maxX) maxX = v.x;
          if (v.y < minY) minY = v.y;
          if (v.y > maxY) maxY = v.y;
        });
        let polyWidth = maxX - minX;
        let polyHeight = maxY - minY;
        let centroid = { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
        offset.x = -centroid.x;
        offset.y = -centroid.y;
        const padding = 50;
        let availWidth = window.innerWidth - 2 * padding;
        let availHeight = window.innerHeight - 2 * padding;
        if (polyWidth > 0 && polyHeight > 0) {
          scaleFactor = Math.min(availWidth / (polyWidth * gridSpacing),
                                 availHeight / (polyHeight * gridSpacing));
        }
        draw();
      }
    });
    unzoomButton.addEventListener('click', function() {
      scaleFactor = 1;
      offset.x = 0;
      offset.y = 0;
      // console.log("View reset (unzoom).");
      draw();
    });

    // --- Central Path Computation ---
    // This function encapsulates the central path request.
    function computeCentralPath() {
      if (!isPolygonConvex(vertices)) {
        analyticResultDiv.innerHTML = "Nonconvex"
        return;
      }
      if (!computedLines || computedLines.length === 0) {
        analyticResultDiv.innerHTML = "No computed lines available.";
        return;
      }
      if (objectiveVector == null) {
        analyticResultDiv.innerHTML = "Objective vector not defined.";
        return;
      }
      let weights = [];
      document.querySelectorAll('.inequality-item').forEach(item => {
        let input = item.querySelector("input");
        weights.push(input ? parseFloat(input.value) : 1);
      });
      fetch('/trace_central_path', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          lines: computedLines,
          objective: [objectiveVector.x, objectiveVector.y],
          weights: weights,
          mu: 100
        })
      })
      .then(response => response.json())
      .then(result => {
        if (result.error) {
          analyticResultDiv.innerHTML = "Error: " + result.error;
        } else {
          centralPath = result.central_path;
          const formattedPath = centralPath.map((entry, i, arr) => {
            const [point, mu] = entry;
            const logMuRounded = parseFloat(Math.log10(mu).toFixed(1));
            const x = point[0].toFixed(2);
            const y = point[1].toFixed(2);

            const logstr = `log(Î¼)=${logMuRounded}`;
            const pointstr = `(${x}, ${y})`;

            const logpadding = '&nbsp;'.repeat(12 - logstr.length);
            const pointpadding = '&nbsp;'.repeat(14 - pointstr.length);
            
            let extra = "";
            if (i > 0) {
              // Get the previous point and its mu value.
              const [prevPoint, prevMu] = arr[i - 1];
              // Compute the (absolute) difference in log(mu)
              const deltaLog = Math.abs(Math.log10(mu) - Math.log10(prevMu));
              // Compute the Euclidean distance between the points.
              const dx = point[0] - prevPoint[0];
              const dy = point[1] - prevPoint[1];
              const stepDistance = Math.sqrt(dx * dx + dy * dy);
              if (deltaLog > 1e-6) { // avoid division by zero
                const ratio = stepDistance / deltaLog;
                extra = `,${pointpadding}Îx: ${ratio.toFixed(2)}`;
              }
            }
            

            return `${logstr}:${logpadding}${pointstr}${extra}`;
          }).join('<br>');
          analyticResultDiv.innerHTML = formattedPath;
          draw();
        }
      })
      .catch(error => {
        console.error('Error:', error);
        analyticResultDiv.innerHTML = "Error computing central path.";
      });
    }

    // --- Trace Central Path (button and auto-update) ---
    traceButton.addEventListener('click', function() {
      computeCentralPath();
      centralPathComputed = true; // remember that the user requested the central path
    });

    // --- Retina Canvas Resizing ---
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      centerX = window.innerWidth / 2;
      centerY = window.innerHeight / 2;
      draw();
    }

    // --- Coordinate Conversion ---
    function toLogicalCoords(x, y) {
      let logical = {
        x: (x - centerX) / (gridSpacing * scaleFactor) - offset.x,
        y: (centerY - y) / (gridSpacing * scaleFactor) - offset.y
      };
      if (snapToGrid) {
        logical.x = Math.round(logical.x);
        logical.y = Math.round(logical.y);
      }
      return logical;
    }
    function toCanvasCoords(x, y) {
      return {
        x: centerX + (x + offset.x) * gridSpacing * scaleFactor,
        y: centerY - (y + offset.y) * gridSpacing * scaleFactor
      };
    }

    // --- Drawing Functions ---
    function drawGrid() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      const originX = centerX + offset.x * gridSpacing * scaleFactor;
      const originY = centerY - offset.y * gridSpacing * scaleFactor;
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 0.5;
      // Vertical lines.
      for (let x = originX; x <= width; x += gridSpacing * scaleFactor) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let x = originX; x >= 0; x -= gridSpacing * scaleFactor) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      // Horizontal lines.
      for (let y = originY; y <= height; y += gridSpacing * scaleFactor) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      for (let y = originY; y >= 0; y -= gridSpacing * scaleFactor) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      // Draw axes.
      ctx.strokeStyle = '#707070';
      ctx.lineWidth = 0.8;
      ctx.beginPath();
      ctx.moveTo(originX, 0);
      ctx.lineTo(originX, height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, originY);
      ctx.lineTo(width, originY);
      ctx.stroke();
    }

    function drawPolygon() {
  if (vertices.length > 0) {
    if (polygonComplete) {
      // Draw each edge one by one.
      for (let i = 0; i < vertices.length; i++) {
        let v1 = vertices[i];
        let v2 = vertices[(i + 1) % vertices.length];
        let cp1 = toCanvasCoords(v1.x, v1.y);
        let cp2 = toCanvasCoords(v2.x, v2.y);
        ctx.beginPath();
        if (highlightIndex === i) {
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 4;
        } else {
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
        }
        ctx.moveTo(cp1.x, cp1.y);
        ctx.lineTo(cp2.x, cp2.y);
        ctx.stroke();
      }
      // Draw vertices.
      vertices.forEach(pt => {
        let cp = toCanvasCoords(pt.x, pt.y);
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(cp.x, cp.y, 4, 0, 2 * Math.PI);
        ctx.fill();
      });
      // If the polygon is nonconvex, fill it with a red overlay.
      if (!isPolygonConvex(vertices)) {
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.beginPath();
        let start = toCanvasCoords(vertices[0].x, vertices[0].y);
        ctx.moveTo(start.x, start.y);
        for (let i = 1; i < vertices.length; i++) {
          let cp = toCanvasCoords(vertices[i].x, vertices[i].y);
          ctx.lineTo(cp.x, cp.y);
        }
        ctx.closePath();
        ctx.fill();
      }
    } else {
      // When the polygon is not complete, draw a single continuous path.
      ctx.beginPath();
      let start = toCanvasCoords(vertices[0].x, vertices[0].y);
      ctx.moveTo(start.x, start.y);
      for (let i = 1; i < vertices.length; i++) {
        let cp = toCanvasCoords(vertices[i].x, vertices[i].y);
        ctx.lineTo(cp.x, cp.y);
      }
      if (currentMouse) {
        let rubberbandEnd = toCanvasCoords(currentMouse.x, currentMouse.y);
        ctx.lineTo(rubberbandEnd.x, rubberbandEnd.y);
      }
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.stroke();
      // Draw vertices.
      vertices.forEach(pt => {
        let cp = toCanvasCoords(pt.x, pt.y);
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(cp.x, cp.y, 4, 0, 2 * Math.PI);
        ctx.fill();
      });
    }
  }
}


    function drawAnalyticCenter() {
      if (analyticCenter != null) {
        let ac = toCanvasCoords(analyticCenter[0], analyticCenter[1]);
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(ac.x, ac.y, 6, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    function drawObjective() {
      let target = null;
      if (objectiveVector != null) {
        target = objectiveVector;
      } else if (polygonComplete && objectiveVector === null && currentObjective != null) {
        target = currentObjective;
      }
      if (target != null) {
        let origin = toCanvasCoords(0, 0);
        let end = toCanvasCoords(target.x, target.y);
        ctx.strokeStyle = 'green';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        let dx = end.x - origin.x, dy = end.y - origin.y;
        let angle = Math.atan2(dy, dx);
        let headLength = 10;
        let angle1 = angle + Math.PI / 6;
        let angle2 = angle - Math.PI / 6;
        let arrowX1 = end.x - headLength * Math.cos(angle1);
        let arrowY1 = end.y - headLength * Math.sin(angle1);
        let arrowX2 = end.x - headLength * Math.cos(angle2);
        let arrowY2 = end.y - headLength * Math.sin(angle2);
        ctx.beginPath();
        ctx.moveTo(end.x, end.y);
        ctx.lineTo(arrowX1, arrowY1);
        ctx.moveTo(end.x, end.y);
        ctx.lineTo(arrowX2, arrowY2);
        ctx.stroke();
      }
    }

    function drawCentralPath() {
      if (centralPath && centralPath.length > 0) {
        ctx.strokeStyle = 'purple';
        ctx.lineWidth = 2;
        ctx.beginPath();
        let start = toCanvasCoords(centralPath[0][0][0], centralPath[0][0][1]);
        ctx.moveTo(start.x, start.y);
        for (let i = 1; i < centralPath.length; i++) {
          let pt = toCanvasCoords(centralPath[i][0][0], centralPath[i][0][1]);
          ctx.lineTo(pt.x, pt.y);
        }
        ctx.stroke();
        ctx.fillStyle = 'purple';
        centralPath.forEach(pt => {
          let cp = toCanvasCoords(pt[0][0], pt[0][1]);
          ctx.beginPath();
          ctx.arc(cp.x, cp.y, 3, 0, 2 * Math.PI);
          ctx.fill();
        });
      }
    }

    function draw() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      ctx.clearRect(0, 0, width, height);
      drawGrid();
      drawPolygon();
      drawAnalyticCenter();
      drawObjective();
      drawCentralPath();
      updateTraceButtonState();
    }

    // --- Ray-Casting for Point-in-Polygon ---
    function isPointInsidePolygon(point, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        let xi = poly[i].x, yi = poly[i].y;
        let xj = poly[j].x, yj = poly[j].y;
        let intersect = ((yi > point.y) !== (yj > point.y)) &&
                        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // --- Mouse Events ---
    let draggingPointIndex = null;
    let draggingObjective = false;
    canvas.addEventListener('mousedown', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      const logicalMouse = toLogicalCoords(mouseX, mouseY);
      // Check if a vertex is clicked.
      for (let i = 0; i < vertices.length; i++) {
        if (distance(logicalMouse, vertices[i]) < 0.5) {
          draggingPointIndex = i;
          return;
        }
      }
      // Check if clicking near the objective arrow tip.
      if (polygonComplete && objectiveVector !== null) {
        const tip = toCanvasCoords(objectiveVector.x, objectiveVector.y);
        if (pixelDistance({ x: mouseX, y: mouseY }, tip) < 10) {
          draggingObjective = true;
          return;
        }
      }
    });

    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      if (draggingPointIndex !== null) {
        vertices[draggingPointIndex] = toLogicalCoords(mouseX, mouseY);
        draw();
        return;
      }
      if (draggingObjective) {
        objectiveVector = toLogicalCoords(mouseX, mouseY);
        updateObjectiveDisplay();
        draw();
        return;
      }
      if (!polygonComplete) {
        currentMouse = toLogicalCoords(mouseX, mouseY);
        draw();
      } else if (polygonComplete && objectiveVector === null) {
        currentObjective = toLogicalCoords(mouseX, mouseY);
        draw();
      }
    });

    canvas.addEventListener('mouseup', function() {
      if (draggingPointIndex !== null) {
        saveState();
        draggingPointIndex = null;
        sendPolytope();
      }
      if (draggingObjective) {
        saveState();
        draggingObjective = false;
        sendPolytope();
      }
    });

    canvas.addEventListener('dblclick', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      const logicalMouse = toLogicalCoords(mouseX, mouseY);
      for (let i = 0; i < vertices.length; i++) {
        let v1 = vertices[i];
        let v2 = vertices[(i + 1) % vertices.length];
        if (isPointNearLine(logicalMouse, v1, v2)) {
          let dx = v2.x - v1.x;
          let dy = v2.y - v1.y;
          let length = Math.sqrt(dx * dx + dy * dy);
          let normal = { x: -dy / length, y: dx / length };
          let adjustmentFactor = 0.1;
          const newPoint = {
            x: logicalMouse.x - normal.x * adjustmentFactor,
            y: logicalMouse.y - normal.y * adjustmentFactor
          };
          saveState();
          vertices.splice(i + 1, 0, newPoint);
          draw();
          sendPolytope();
          break;
        }
      }
    });

    function isPointNearLine(point, v1, v2) {
      const dist = Math.abs((v2.y - v1.y) * point.x - (v2.x - v1.x) * point.y + v2.x * v1.y - v2.y * v1.x) /
                   Math.sqrt((v2.y - v1.y) ** 2 + (v2.x - v1.x) ** 2);
      return dist < 0.5;
    }

    canvas.addEventListener('click', function(event) {
      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;
      let pt = toLogicalCoords(clickX, clickY);
      if (!polygonComplete) {
        if (vertices.length >= 3) {
          const closeThreshold = 0.5;
          if (distance(pt, vertices[0]) < closeThreshold) {
            polygonComplete = true;
            interiorPoint = computeCentroid(vertices);
            draw();
            sendPolytope();
            return;
          }
          if (isPointInsidePolygon(pt, vertices)) {
            polygonComplete = true;
            interiorPoint = pt;
            draw();
            sendPolytope();
            return;
          }
        }
        let tentative = vertices.slice();
        tentative.push(pt);
        if (tentative.length >= 3 && !isPolygonConvex(tentative)) {
          alert("Adding this vertex would make the polygon nonconvex. Please choose another point.");
          return;
        }
        saveState();
        vertices.push(pt);
        draw();
        sendPolytope();
      } else if (polygonComplete && objectiveVector === null) {
        saveState();
        objectiveVector = currentObjective ? currentObjective : pt;
        updateObjectiveDisplay();
        draw();
        return;
      }
    });

    function isPolygonConvex(pts) {
      if (pts.length < 3) return true;
      let n = pts.length;
      let prevCross = 0;
      for (let i = 0; i < n; i++) {
        let p0 = pts[i];
        let p1 = pts[(i + 1) % n];
        let p2 = pts[(i + 2) % n];
        let dx1 = p1.x - p0.x, dy1 = p1.y - p0.y;
        let dx2 = p2.x - p1.x, dy2 = p2.y - p1.y;
        let cross = dx1 * dy2 - dy1 * dx2;
        if (cross !== 0) {
          if (prevCross === 0) prevCross = cross;
          else if (Math.sign(cross) !== Math.sign(prevCross)) return false;
        }
      }
      return true;
    }
    function updateTraceButtonState() {
      traceButton.disabled = !isPolygonConvex(vertices);
    }

    // --- Send Polytope and Auto-update Central Path ---
    function sendPolytope() {
      const data = {
        points: vertices.map(pt => [pt.x, pt.y]),
        interior: interiorPoint ? [interiorPoint.x, interiorPoint.y] : null
      };
      fetch('/polytope', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })
      .then(response => response.json())
      .then(result => {
        if (result.inequalities) {
          let html = "";
          if (!isPolygonConvex(vertices)) {
            inequalitiesDiv.innerHTML = "Nonconvex"
            return;
          }
          result.inequalities.forEach((ineq, index) => {
            html += `<div class="inequality-item" data-index="${index}">
                       ${ineq}<br><span style="font-family: sans-serif;">Barrier weight:</span>
                       <input type="number" id="weight-${index}" value="1" step="any" style="width:60px" />
                     </div>`;
          });
          inequalitiesDiv.innerHTML = html;
          document.querySelectorAll('.inequality-item').forEach(item => {
            item.addEventListener('mouseenter', function() {
              highlightIndex = parseInt(this.getAttribute('data-index'));
              draw();
            });
            item.addEventListener('mouseleave', function() {
              highlightIndex = null;
              draw();
            });
          });
        } else {
          inequalitiesDiv.textContent = "No inequalities returned.";
        }
        computedVertices = result.vertices;
        computedLines = result.lines;
        // If a central path was already computed and we have an objective vector,
        // automatically recompute the central path.
        if (centralPathComputed && objectiveVector != null && computedLines && computedLines.length > 0) {
          computeCentralPath();
        }
      })
      .catch(error => {
        console.error('Error:', error);
        inequalitiesDiv.textContent = "Error computing inequalities.";
      });
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
  </script>
  <div id="sidebarHandle"></div>
  <script>
    const sidebar = document.getElementById('sidebar');
    const handle = document.getElementById('sidebarHandle');
  
    let isResizing = false;
  
    handle.addEventListener('mousedown', function(e) {
      isResizing = true;
      e.preventDefault(); // Prevent text selection, etc.
    });
  
    document.addEventListener('mousemove', function(e) {
      if (!isResizing) return;
      
      // Determine the new width. Here, e.clientX is the horizontal coordinate.
      let newWidth = e.clientX;
      
      // Enforce minimum and maximum widths (in pixels)
      if (newWidth < 200) newWidth = 200;
      if (newWidth > 600) newWidth = 600;
      
      // Apply the new width to the sidebar
      sidebar.style.width = newWidth + 'px';
      
      // Reposition the handle to match the sidebar's new right edge
      handle.style.left = newWidth + 'px';
    });
  
    document.addEventListener('mouseup', function(e) {
      if (isResizing) {
        isResizing = false;
      }
    });
  </script>
  
</body>
</html>
