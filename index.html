<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JuMPGUI</title>
  <style>
    html, body { margin: 0; height: 100%; }
    body { display: flex; font-family: sans-serif; }
    /* Sidebar for instructions and controls */
    #sidebar {
      width: 250px;
      background-color: #f0f0f0;
      padding: 10px;
      box-sizing: border-box;
      overflow-y: auto;
      border-right: 1px solid #ccc;
    }
    #sidebar button { margin-top: 10px; padding: 5px 10px; }
    .inequality-item { padding: 4px; cursor: pointer; }
    .inequality-item:hover { background-color: #e0e0ff; }
    /* Main container for the canvas */
    #canvas-container { flex-grow: 1; position: relative; }
    canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>Constraints</h2>
    <div id="inequalities">
      Draw a polytope by clicking on the canvas.
      To complete it, either click near the first vertex
      or click inside the shape to complete it.
      After the polytope, set the objective.<br>
      <br><br><br><br>
    </div>
    <!-- New Objective section -->
    <h2>Objective</h2>
    <div id="objectiveDisplay">No objective defined.</div>
    <button id="zoomButton">Zoom</button>
    <!-- Added Unzoom button below -->
    <button id="unzoomButton">Unzoom</button>
    <button id="traceButton">Trace Central Path</button>
    <div id="analyticResult"></div>
    <div><br><br> Press the <strong>S</strong> key to toggle snapping to the grid.</div>
  </div>
  <div id="canvas-container">
    <canvas id="gridCanvas"></canvas>
  </div>
  <script>
    const canvas = document.getElementById('gridCanvas');
    const ctx = canvas.getContext('2d');
    const inequalitiesDiv = document.getElementById('inequalities');
    const zoomButton = document.getElementById('zoomButton');
    const unzoomButton = document.getElementById('unzoomButton'); // New button element
    const traceButton = document.getElementById('traceButton');
    const analyticResultDiv = document.getElementById('analyticResult');
    const objectiveDisplay = document.getElementById('objectiveDisplay'); // New element for objective display

    let centerX, centerY;
    const gridSpacing = 20; // base pixels per grid unit

    // Global transformation variables:
    let offset = { x: 0, y: 0 };
    let scaleFactor = 1;

    // Variables for polygon drawing (in grid units)
    let vertices = [];       // User-clicked vertices [{x, y}, ...]
    let currentMouse = null; // Current mouse position (in grid units) while drawing vertices
    let polygonComplete = false;
    let interiorPoint = null; // The interior point when polygon is complete

    // New: objective vector (fixed by click) and currentObjective (rubberband candidate)
    let objectiveVector = null;
    let currentObjective = null;

    // These will be filled from the backend.
    let computedVertices = [];  // Computed intersection vertices
    let computedLines = [];     // Array of line parameters [A, B, C]

    // Global flags.
    let snapToGrid = false;
    let highlightIndex = null;
    let analyticCenter = null;
    let centralPath = [];  // To store the central path (an array of points)

    // Toggle snapping with S key.
    window.addEventListener('keydown', function(e) {
      if (e.key.toLowerCase() === 's') {
        snapToGrid = !snapToGrid;
        console.log("Snap to grid:", snapToGrid);
      }
    });

    // Helper functions.
    function distance(p1, p2) {
      return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
    }
    function computeCentroid(pts) {
      let sumX = 0, sumY = 0;
      pts.forEach(pt => { sumX += pt.x; sumY += pt.y; });
      return { x: sumX / pts.length, y: sumY / pts.length };
    }

    // Function to update the normalized objective display.
    function updateObjectiveDisplay() {
      if (objectiveVector != null) {
        // let norm = Math.sqrt(objectiveVector.x**2 + objectiveVector.y**2);
        // if (norm === 0) norm = 1;
        let a = objectiveVector.x;// / norm;
        let b = objectiveVector.y;// / norm;
        // Round to three decimals
        a = Math.round(a * 1000) / 1000;
        b = Math.round(b * 1000) / 1000;
        let str = "" + a + "x";
        if (b >= 0) {
          str += " + " + b + "y";
        } else {
          str += " - " + (-b) + "y";
        }
        objectiveDisplay.innerHTML = str;
      } else {
        objectiveDisplay.innerHTML = "No objective defined.";
      }
    }

    // Zoom button: recenter and scale using computedVertices.
    zoomButton.addEventListener('click', function() {
      if (vertices && vertices.length > 0) {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        vertices.forEach(v => {
          if (v.x < minX) minX = v.x;
          if (v.x > maxX) maxX = v.x;
          if (v.y < minY) minY = v.y;
          if (v.y > maxY) maxY = v.y;
        });
        let polyWidth = maxX - minX;
        let polyHeight = maxY - minY;
        let centroid = { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
        offset.x = -centroid.x;
        offset.y = -centroid.y;
        const padding = 50;
        let availWidth = canvas.width - 2 * padding;
        let availHeight = canvas.height - 2 * padding;
        let newScaleFactor = scaleFactor;
        if (polyWidth > 0 && polyHeight > 0) {
          newScaleFactor = Math.min(availWidth / (polyWidth * gridSpacing),
                                    availHeight / (polyHeight * gridSpacing));
        }
        scaleFactor = newScaleFactor;
        // console.log("New scaleFactor:", scaleFactor);
        draw();
      }
    });

    // Unzoom button: reset the view to the default (scaleFactor 1 and centered offset).
    unzoomButton.addEventListener('click', function() {
      scaleFactor = 1;
      offset.x = 0;
      offset.y = 0;
      console.log("View reset (unzoom).");
      draw();
    });

    // Trace Central Path button: send computedLines, objective vector, weights, and mu to backend.
    traceButton.addEventListener('click', function() {
      if (!computedLines || computedLines.length === 0) {
        analyticResultDiv.innerHTML = "No computed lines available.";
        return;
      }
      if (objectiveVector == null) {
        analyticResultDiv.innerHTML = "Objective vector not defined.";
        return;
      }
      // Collect the weights from each inequality input.
      let weights = [];
      document.querySelectorAll('.inequality-item').forEach(item => {
        let input = item.querySelector("input");
        if (input) {
          weights.push(parseFloat(input.value));
        } else {
          weights.push(1);
        }
      });
      fetch('/trace_central_path', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          lines: computedLines,
          objective: [objectiveVector.x, objectiveVector.y],
          weights: weights,
          mu: 100  // This parameter is not used directly, as the backend uses powers of 10.
        })
      })
      .then(response => response.json())
      .then(result => {
        if (result.error) {
          analyticResultDiv.innerHTML = "Error: " + result.error;
        } else {
          centralPath = result.central_path;
          analyticResultDiv.innerHTML = "Central Path (points): " + JSON.stringify(centralPath);
          draw();
        }
      })
      .catch(error => {
        console.error('Error:', error);
        analyticResultDiv.innerHTML = "Error computing central path.";
      });
    });

    function resizeCanvas() {
      const container = document.getElementById('canvas-container');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      centerX = canvas.width / 2;
      centerY = canvas.height / 2;
      draw();
    }

    // Conversion functions.
    function toLogicalCoords(x, y) {
      let logical = {
        x: (x - centerX) / (gridSpacing * scaleFactor) - offset.x,
        y: (centerY - y) / (gridSpacing * scaleFactor) - offset.y
      };
      if (snapToGrid) {
        logical.x = Math.round(logical.x);
        logical.y = Math.round(logical.y);
      }
      return logical;
    }
    function toCanvasCoords(x, y) {
      return {
        x: centerX + (x + offset.x) * gridSpacing * scaleFactor,
        y: centerY - (y + offset.y) * gridSpacing * scaleFactor
      };
    }

    // Draw the grid.
    function drawGrid() {
      const width = canvas.width;
      const height = canvas.height;
      const originX = centerX + offset.x * gridSpacing * scaleFactor;
      const originY = centerY - offset.y * gridSpacing * scaleFactor;
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      for (let x = originX; x <= width; x += gridSpacing * scaleFactor) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let x = originX; x >= 0; x -= gridSpacing * scaleFactor) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = originY; y <= height; y += gridSpacing * scaleFactor) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      for (let y = originY; y >= 0; y -= gridSpacing * scaleFactor) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(originX, 0);
      ctx.lineTo(originX, height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, originY);
      ctx.lineTo(width, originY);
      ctx.stroke();
    }

    // Add event listeners for dragging points and double-clicking on lines
    let draggingPointIndex = null;
    let newPoint = null;

    canvas.addEventListener('mousedown', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      const logicalMouse = toLogicalCoords(mouseX, mouseY);

      // Check if a vertex is clicked for dragging
      vertices.forEach((vertex, index) => {
        if (distance(logicalMouse, vertex) < 0.5) {
          draggingPointIndex = index;
        }
      });
    });

    canvas.addEventListener('mousemove', function(event) {
      if (draggingPointIndex !== null) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        vertices[draggingPointIndex] = toLogicalCoords(mouseX, mouseY);
        draw();
      }
    });

    canvas.addEventListener('mouseup', function() {
      if (draggingPointIndex !== null) {
        draggingPointIndex = null;
        sendPolytope(); // Update backend with new polygon data
      }
    });

    canvas.addEventListener('dblclick', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      const logicalMouse = toLogicalCoords(mouseX, mouseY);

      // Check if double-click is near a line to add a new point
      for (let i = 0; i < vertices.length; i++) {
        let v1 = vertices[i];
        let v2 = vertices[(i + 1) % vertices.length];
        if (isPointNearLine(logicalMouse, v1, v2)) {
          // Calculate the normal vector of the line
          let dx = v2.x - v1.x;
          let dy = v2.y - v1.y;
          let length = Math.sqrt(dx * dx + dy * dy);
          let normal = { x: -dy / length, y: dx / length };

          // Adjust the new point slightly along the normal vector
          let adjustmentFactor = 0.1; // Adjust this factor as needed
          newPoint = {
            x: logicalMouse.x - normal.x * adjustmentFactor,
            y: logicalMouse.y - normal.y * adjustmentFactor
          };

          vertices.splice(i + 1, 0, newPoint);
          draw();
          sendPolytope(); // Update backend with new polygon data
          break;
        }
      }
    });

    function isPointNearLine(point, v1, v2) {
      const dist = Math.abs((v2.y - v1.y) * point.x - (v2.x - v1.x) * point.y + v2.x * v1.y - v2.y * v1.x) /
                  Math.sqrt((v2.y - v1.y) ** 2 + (v2.x - v1.x) ** 2);
      return dist < 0.5;
    }

    // Update drawPolygon to handle non-convex polygons
    function drawPolygon() {
      if (vertices.length > 0) {
        ctx.beginPath();
        let start = toCanvasCoords(vertices[0].x, vertices[0].y);
        ctx.moveTo(start.x, start.y);
        for (let i = 1; i < vertices.length; i++) {
          let cp = toCanvasCoords(vertices[i].x, vertices[i].y);
          ctx.lineTo(cp.x, cp.y);
        }
        if (!polygonComplete && currentMouse) {
          // Draw rubberband line to current mouse position
          let rubberbandEnd = toCanvasCoords(currentMouse.x, currentMouse.y);
          ctx.lineTo(rubberbandEnd.x, rubberbandEnd.y);
        }
        ctx.closePath();

        if (!isPolygonConvex(vertices)) {
          ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; // Red with 30% opacity
          ctx.fill();
        }

        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 2;
        ctx.stroke();

        vertices.forEach(pt => {
          let cp = toCanvasCoords(pt.x, pt.y);
          ctx.fillStyle = 'red';
          ctx.beginPath();
          ctx.arc(cp.x, cp.y, 4, 0, 2 * Math.PI);
          ctx.fill();
        });
      }
    }

    // Draw the analytic center as a black circle.
    function drawAnalyticCenter() {
      if (analyticCenter != null) {
        let ac = toCanvasCoords(analyticCenter[0], analyticCenter[1]);
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(ac.x, ac.y, 6, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    // Draw the objective arrow.
    // If objectiveVector is fixed, draw that.
    // Otherwise, if the polytope is complete and no objective is fixed, use the rubberband arrow from currentObjective.
    function drawObjective() {
      let target = null;
      if (objectiveVector != null) {
        target = objectiveVector;
      } else if (polygonComplete && objectiveVector === null && currentObjective != null) {
        target = currentObjective;
      }
      if (target != null) {
        let origin = toCanvasCoords(0, 0);
        let end = toCanvasCoords(target.x, target.y);
        ctx.strokeStyle = 'green';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        // Draw arrowhead.
        let dx = end.x - origin.x, dy = end.y - origin.y;
        let angle = Math.atan2(dy, dx);
        let headLength = 10;
        let angle1 = angle + Math.PI / 6;
        let angle2 = angle - Math.PI / 6;
        let arrowX1 = end.x - headLength * Math.cos(angle1);
        let arrowY1 = end.y - headLength * Math.sin(angle1);
        let arrowX2 = end.x - headLength * Math.cos(angle2);
        let arrowY2 = end.y - headLength * Math.sin(angle2);
        ctx.beginPath();
        ctx.moveTo(end.x, end.y);
        ctx.lineTo(arrowX1, arrowY1);
        ctx.moveTo(end.x, end.y);
        ctx.lineTo(arrowX2, arrowY2);
        ctx.stroke();
      }
    }

    // Draw the central path returned by the backend.
    function drawCentralPath() {
      if (centralPath && centralPath.length > 0) {
        ctx.strokeStyle = 'purple';
        ctx.lineWidth = 2;
        ctx.beginPath();
        // Assume each element of centralPath is a 2-element array [x, y]
        let start = toCanvasCoords(centralPath[0][0], centralPath[0][1]);
        ctx.moveTo(start.x, start.y);
        for (let i = 1; i < centralPath.length; i++) {
          let pt = toCanvasCoords(centralPath[i][0], centralPath[i][1]);
          ctx.lineTo(pt.x, pt.y);
        }
        ctx.stroke();
        // Draw small circles at each central path point.
        ctx.fillStyle = 'purple';
        centralPath.forEach(pt => {
          let cp = toCanvasCoords(pt[0], pt[1]);
          ctx.beginPath();
          ctx.arc(cp.x, cp.y, 3, 0, 2 * Math.PI);
          ctx.fill();
        });
      }
    }

    // Redraw the entire canvas.
    function draw() {
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);
      drawGrid();
      drawPolygon();
      drawAnalyticCenter();
      drawObjective();
      drawCentralPath();
      updateTraceButtonState();
    }

    // Ray-casting algorithm.
    function isPointInsidePolygon(point, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        let xi = poly[i].x, yi = poly[i].y;
        let xj = poly[j].x, yj = poly[j].y;
        let intersect = ((yi > point.y) !== (yj > point.y)) &&
                        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // Mousemove handler:
    // - If the polytope is not complete, update currentMouse.
    // - If the polytope is complete and objectiveVector is not fixed, update currentObjective.
    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      if (!polygonComplete) {
        currentMouse = toLogicalCoords(mouseX, mouseY);
      } else if (polygonComplete && objectiveVector === null) {
        currentObjective = toLogicalCoords(mouseX, mouseY);
      }
      draw();
    });

    // Click handler:
    // - Before polygon completion, add vertices or complete the polygon.
    // - Once polygon is complete and objectiveVector is null, fix the objective vector.
    canvas.addEventListener('click', function(event) {
      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;
      let pt = toLogicalCoords(clickX, clickY);
      if (!polygonComplete) {
        if (vertices.length >= 3) {
          const closeThreshold = 0.5;
          if (distance(pt, vertices[0]) < closeThreshold) {
            polygonComplete = true;
            interiorPoint = computeCentroid(vertices);
            draw();
            sendPolytope();
            return;
          }
          if (isPointInsidePolygon(pt, vertices)) {
            polygonComplete = true;
            interiorPoint = pt;
            draw();
            sendPolytope();
            return;
          }
        }
        let tentative = vertices.slice();
        tentative.push(pt);
        if (tentative.length >= 3 && !isPolygonConvex(tentative)) {
          alert("Adding this vertex would make the polygon nonconvex. Please choose another point.");
          return;
        }
        vertices.push(pt);
        draw();
      } else if (polygonComplete && objectiveVector === null) {
        // Fix the objective vector using the current rubberband candidate.
        objectiveVector = currentObjective ? currentObjective : pt;
        updateObjectiveDisplay(); // Update the Objective section
        draw();
        return;
      }
    });

    function isPolygonConvex(pts) {
      if (pts.length < 3) return true;
      let n = pts.length;
      let prevCross = 0;
      for (let i = 0; i < n; i++) {
        let p0 = pts[i];
        let p1 = pts[(i + 1) % n];
        let p2 = pts[(i + 2) % n];
        let dx1 = p1.x - p0.x, dy1 = p1.y - p0.y;
        let dx2 = p2.x - p1.x, dy2 = p2.y - p1.y;
        let cross = dx1 * dy2 - dy1 * dx2;
        if (cross !== 0) {
          if (prevCross === 0) prevCross = cross;
          else if (Math.sign(cross) !== Math.sign(prevCross)) return false;
        }
      }
      return true;
    }
    // Function to update the state of the Trace Central Path button
    function updateTraceButtonState() {
      if (isPolygonConvex(vertices)) {
        traceButton.disabled = false;
      } else {
        traceButton.disabled = true;
      }
    }

    function sendPolytope() {
      const data = {
        points: vertices.map(pt => [pt.x, pt.y]),
        interior: [interiorPoint.x, interiorPoint.y]
      };
      fetch('/polytope', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })
      .then(response => response.json())
      .then(result => {
        if (result.inequalities) {
          let html = "";
          result.inequalities.forEach((ineq, index) => {
            html += `<div class="inequality-item" data-index="${index}">
                       ${ineq} <br> Barrier weight: <input type="number" id="weight-${index}" value="1" step="any" style="width:60px" />
                     </div>`;
          });
          inequalitiesDiv.innerHTML = html;
          document.querySelectorAll('.inequality-item').forEach(item => {
            item.addEventListener('mouseenter', function() {
              highlightIndex = parseInt(this.getAttribute('data-index'));
              draw();
            });
            item.addEventListener('mouseleave', function() {
              highlightIndex = null;
              draw();
            });
          });
        } else {
          inequalitiesDiv.textContent = "No inequalities returned.";
        }
        computedVertices = result.vertices;
        computedLines = result.lines;  // each element is [A, B, C]
      })
      .catch(error => {
        console.error('Error:', error);
        inequalitiesDiv.textContent = "Error computing inequalities.";
      });
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
  </script>
</body>
</html>
