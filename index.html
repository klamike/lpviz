<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>lpviz</title>
    <style>
      @font-face {
        font-family: 'JuliaMono';
        src: url("https://cdn.jsdelivr.net/gh/cormullion/juliamono-webfonts/JuliaMono-Light.woff2") format('woff2');
      }

      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
      }

      body {
        font-family: 'JuliaMono', monospace;
        font-size: 10pt;
      }

      /* Fullscreen canvas */
      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
      }

      /* Sidebar overlaid on top of the canvas */
      #sidebar {
        position: fixed;
        top: 0;
        left: 0;
        width: 380px;
        height: 100%;
        padding: 10px;
        box-sizing: border-box;
        background-color: rgba(240, 240, 240, 1);
        border-right: 1px solid #ccc;
        overflow-y: auto;
        z-index: 10;
      }

      /* The content inside the sidebar uses flex layout:
         the spacer pushes the usage tips to the bottom */
      #sidebarContent {
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      /* The spacer will expand to push usage tips down */
      .spacer {
        flex-grow: 1;
        min-height: 0;
      }

      #usageTips {
        font-size: 0.8em;
      }

      #sidebar h2 {
        margin-bottom: 5px;
        letter-spacing: -0.5px;
        font-family: sans-serif;
      }

      #sidebar button {
        margin-top: 10px;
        padding: 5px 10px;
      }

      hr {
        margin-top: 10px;
        color: #e5e5e5;
        background-color: #e5e5e5;
      }

      .inequality-item {
        padding: 4px;
        cursor: pointer;
      }
      .inequality-item:hover {
        background-color: #e0e0ff;
      }
      .objective-item {
        padding: 4px;
        cursor: pointer;
      }
      .objective-item:hover {
        background-color: #e0e0ff;
      }
      .central-path-item:hover {
        background-color: #e0e0ff;
      }
      #sidebarHandle {
        position: fixed;
        top: 0;
        left: 380px;
        width: 5px;
        height: 100%;
        cursor: ew-resize;
        z-index: 20;
        background: rgba(0, 0, 0, 0.1);
      }
    </style>
  </head>
  <body>
    <div id="sidebar">
      <div id="sidebarContent">
        <h1>lpviz</h1>
        <hr>
        <!-- Null state message displayed when no drawing exists -->
        <div id="nullStateMessage" style="text-align: center; font-size: 1.25em; margin: 20px 0;">
          Start drawing!
        </div>
        <!-- UI container with full controls, hidden until a drawing exists -->
        <div id="uiContainer" style="display: none;">
          <h2>Objective</h2>
          <div id="objectiveDisplay"></div>
          <h2>Constraints</h2>
          <div id="inequalities"></div>
          <br>
          <br>
          <hr>
          <button id="traceButton">Trace Central Path</button>
          <br>
          <button id="rotateObjectiveButton">Toggle Rotate Objective</button>
          <br>
          <button id="zoomButton">Zoom</button>
          <button id="unzoomButton">Unzoom</button>
          <br>
          <button id="toggleBarrierWeightsButton">Show Barrier Weights</button>
          <br><br>
          <hr>
          <h2>Central Path</h2>
          <div id="analyticResult"></div>
          <hr>
        </div>
        <div class="spacer"></div>
        <div id="usageTips">
          <br><br><br><br>
          <strong style="font-size: 1.25em;">Usage Tips:</strong><br><br>
          <strong>Draw</strong>: click to add vertices, click inside when done.<br>
          <strong>Move</strong>: drag vertices to reshape.<br>
          <strong>Add</strong>: double-click an edge to insert a vertex.<br>
          <strong>Red Overlay</strong>: indicates non-convexity, must adjust.<br>
          <strong>Zoom</strong>: fits the polygon in view.<br>
          <strong>Objective</strong>: drag the objective arrow to adjust direction.<br>
          <strong>Press S</strong>: toggle snapping to the grid.
        </div>
      </div>
    </div>

    <canvas id="gridCanvas"></canvas>

    <script>
      const canvas = document.getElementById('gridCanvas');
      const ctx = canvas.getContext('2d');
      const inequalitiesDiv = document.getElementById('inequalities');
      const zoomButton = document.getElementById('zoomButton');
      const unzoomButton = document.getElementById('unzoomButton');
      const traceButton = document.getElementById('traceButton');
      const analyticResultDiv = document.getElementById('analyticResult');
      const objectiveDisplay = document.getElementById('objectiveDisplay');

      let centerX, centerY;
      const gridSpacing = 20;

      let offset = { x: 0, y: 0 };
      let scaleFactor = 1;

      let vertices = [];
      let currentMouse = null;
      let polygonComplete = false;
      let interiorPoint = null;
      let objectiveVector = null;
      let currentObjective = null;

      let computedVertices = [];
      let computedLines = [];

      let snapToGrid = false;
      let highlightIndex = null;
      let analyticCenter = null;
      let centralPath = [];
      let centralPathComputed = false;
      let historyStack = [];
      let redoStack = [];

      let highlightCentralPathIndex = null;
      let isCentralPathComputing = false;

      function updateSidebarUI() {
        const uiContainer = document.getElementById('uiContainer');
        const nullStateMessage = document.getElementById('nullStateMessage');
        if (vertices.length === 0) {
          uiContainer.style.display = 'none';
          nullStateMessage.style.display = 'block';
        } else {
          uiContainer.style.display = 'block';
          nullStateMessage.style.display = 'none';
        }
      }

      function updateZoomButtonsState() {
        if (scaleFactor === 1 && offset.x === 0 && offset.y === 0) {
          unzoomButton.disabled = true;
          zoomButton.disabled = false;
        } else {
          unzoomButton.disabled = false;
          zoomButton.disabled = true;
        }
      }

      function saveState() {
        historyStack.push({
          vertices: JSON.parse(JSON.stringify(vertices)),
          objectiveVector: objectiveVector ? { ...objectiveVector } : null
        });
        redoStack = [];
      }
      function undo() {
        if (historyStack.length > 0) {
          const lastState = historyStack.pop();
          redoStack.push({
            vertices: JSON.parse(JSON.stringify(vertices)),
            objectiveVector: objectiveVector ? { ...objectiveVector } : null
          });
          vertices = lastState.vertices;
          objectiveVector = lastState.objectiveVector;
          updateSidebarUI();
          draw();
          sendPolytope();
        }
      }
      function redo() {
        if (redoStack.length > 0) {
          const nextState = redoStack.pop();
          historyStack.push({
            vertices: JSON.parse(JSON.stringify(vertices)),
            objectiveVector: objectiveVector ? { ...objectiveVector } : null
          });
          vertices = nextState.vertices;
          objectiveVector = nextState.objectiveVector;
          updateSidebarUI();
          draw();
          sendPolytope();
        }
      }
      window.addEventListener('keydown', function (e) {
        if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'z' && !e.shiftKey) {
          e.preventDefault();
          undo();
        }
        if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'z' && e.shiftKey) {
          e.preventDefault();
          redo();
        }
      });
      window.addEventListener('keydown', function (e) {
        if (e.key.toLowerCase() === 's') {
          snapToGrid = !snapToGrid;
        }
      });

      function distance(p1, p2) {
        return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
      }
      function pixelDistance(p1, p2) {
        return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
      }
      function computeCentroid(pts) {
        let sumX = 0, sumY = 0;
        pts.forEach(pt => { sumX += pt.x; sumY += pt.y; });
        return { x: sumX / pts.length, y: sumY / pts.length };
      }
      function updateObjectiveDisplay() {
        if (objectiveVector != null) {
          let a = Math.round(objectiveVector.x * 1000) / 1000;
          let b = Math.round(objectiveVector.y * 1000) / 1000;
          let str = a + "x" + (b >= 0 ? " + " + b + "y" : " - " + (-b) + "y");
          objectiveDisplay.classList.add('objective-item');
          objectiveDisplay.innerHTML = "Max " + str;
        } else {
          objectiveDisplay.classList.remove('objective-item');
          objectiveDisplay.innerHTML = "";
        }
      }

      zoomButton.addEventListener('click', function () {
        if (vertices.length > 0) {
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          vertices.forEach(v => {
            if (v.x < minX) minX = v.x;
            if (v.x > maxX) maxX = v.x;
            if (v.y < minY) minY = v.y;
            if (v.y > maxY) maxY = v.y;
          });
          let polyWidth = maxX - minX;
          let polyHeight = maxY - minY;
          let centroid = { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };

          offset.x = -centroid.x;
          offset.y = -centroid.y;

          const padding = 50;
          const sidebarWidth = document.getElementById('sidebar').offsetWidth;
          let availWidth = (window.innerWidth - sidebarWidth) - 2 * padding;
          let availHeight = window.innerHeight - 2 * padding;

          if (polyWidth > 0 && polyHeight > 0) {
            scaleFactor = Math.min(availWidth / (polyWidth * gridSpacing),
              availHeight / (polyHeight * gridSpacing));
          }

          centerX = sidebarWidth + (window.innerWidth - sidebarWidth) / 2;
          centerY = window.innerHeight / 2;

          draw();
          updateZoomButtonsState();
        }
      });

      unzoomButton.addEventListener('click', function () {
        scaleFactor = 1;
        offset.x = 0;
        offset.y = 0;
        draw();
        updateZoomButtonsState();
      });

      function computeCentralPath() {
        if (isCentralPathComputing) return Promise.resolve();
        isCentralPathComputing = true;
        if (!isPolygonConvex(vertices)) {
          analyticResultDiv.innerHTML = "Nonconvex";
          isCentralPathComputing = false;
          return Promise.resolve();
        }
        if (!computedLines || computedLines.length === 0) {
          analyticResultDiv.innerHTML = "No computed lines available.";
          isCentralPathComputing = false;
          return Promise.resolve();
        }
        if (objectiveVector == null) {
          analyticResultDiv.innerHTML = "Objective vector not defined.";
          isCentralPathComputing = false;
          return Promise.resolve();
        }

        let weights = [];
        document.querySelectorAll('.inequality-item').forEach(item => {
          let input = item.querySelector("input");
          weights.push(input ? parseFloat(input.value) : 1);
        });

        return fetch('/trace_central_path', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            lines: computedLines,
            objective: [objectiveVector.x, objectiveVector.y],
            weights: weights,
            mu: 100
          })
        })
          .then(response => response.json())
          .then(result => {
            if (result.error) {
              analyticResultDiv.innerHTML = "Error: " + result.error;
              isCentralPathComputing = false;
              return;
            }

            centralPath = result.central_path;
            const formattedPath = centralPath.map((entry, i, arr) => {
              const [point, mu] = entry;
              const logMuRounded = parseFloat(Math.log10(mu).toFixed(1));
              const x = point[0].toFixed(2);
              const y = point[1].toFixed(2);
              const logmupadding = `&nbsp;`.repeat(Math.max(0, 5 - logMuRounded.toString().length));
              let extra = "";
              if (i > 0) {
                const [prevPoint, prevMu] = arr[i - 1];
                const deltaLog = Math.abs(Math.log10(mu) - Math.log10(prevMu));
                const dx = point[0] - prevPoint[0];
                const dy = point[1] - prevPoint[1];
                const stepDistance = Math.sqrt(dx * dx + dy * dy);
                if (deltaLog > 1e-6) {
                  const ratio = stepDistance / deltaLog;
                  const pointpadding = `&nbsp;`.repeat(Math.max(0, 17 - `(${x}, ${y})`.length));
                  extra = `${pointpadding}Δx: ${ratio.toFixed(2)}`;
                }
              }
              return `<div class="central-path-item" data-index="${i}">log(μ)=${logMuRounded}:${logmupadding}(${x}, ${y})${extra}</div>`;
            }).join('');

            analyticResultDiv.innerHTML = formattedPath;
            document.querySelectorAll('.central-path-item').forEach(item => {
              item.addEventListener('mouseenter', function () {
                highlightCentralPathIndex = parseInt(this.getAttribute('data-index'));
                draw();
              });
              item.addEventListener('mouseleave', function () {
                highlightCentralPathIndex = null;
                draw();
              });
            });

            draw();
            isCentralPathComputing = false;
          })
          .catch(error => {
            console.error('Error:', error);
            analyticResultDiv.innerHTML = "Error computing central path.";
            isCentralPathComputing = false;
          });
      }

      traceButton.addEventListener('click', function () {
        computeCentralPath();
        centralPathComputed = true;
      });

      let rotateObjectiveMode = false;
      const rotateObjectiveButton = document.getElementById('rotateObjectiveButton');

      function rotateAndComputeStep() {
        const MIN_WAIT = 30;
        if (!isPolygonConvex(vertices)) {
          setTimeout(rotateAndComputeStep, MIN_WAIT);
          return;
        }
        if (!rotateObjectiveMode) return;
        let angle = Math.atan2(objectiveVector.y, objectiveVector.x);
        let magnitude = Math.sqrt(objectiveVector.x ** 2 + objectiveVector.y ** 2);
        angle += 0.1;
        objectiveVector = { x: magnitude * Math.cos(angle), y: magnitude * Math.sin(angle) };
        updateObjectiveDisplay();
        draw();
        if (polygonComplete && computedLines && computedLines.length > 0) {
          computeCentralPath().then(() => {
            if (rotateObjectiveMode) {
              setTimeout(rotateAndComputeStep, MIN_WAIT);
            }
          });
        } else {
          if (rotateObjectiveMode) {
            setTimeout(rotateAndComputeStep, MIN_WAIT);
          }
        }
      }

      rotateObjectiveButton.addEventListener('click', function () {
        rotateObjectiveMode = !rotateObjectiveMode;
        if (rotateObjectiveMode) {
          if (objectiveVector == null) {
            objectiveVector = { x: 1, y: 0 };
            updateObjectiveDisplay();
          }
          rotateAndComputeStep();
        }
      });

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        updateCenter();
        draw();
        updateZoomButtonsState();
      }
      function updateCenter() {
        const sidebarWidth = document.getElementById('sidebar').offsetWidth;
        centerX = sidebarWidth + (window.innerWidth - sidebarWidth) / 2;
        centerY = window.innerHeight / 2;
      }

      function toLogicalCoords(x, y) {
        let logical = {
          x: (x - centerX) / (gridSpacing * scaleFactor) - offset.x,
          y: (centerY - y) / (gridSpacing * scaleFactor) - offset.y
        };
        if (snapToGrid) {
          logical.x = Math.round(logical.x);
          logical.y = Math.round(logical.y);
        }
        return logical;
      }
      function toCanvasCoords(x, y) {
        return {
          x: centerX + (x + offset.x) * gridSpacing * scaleFactor,
          y: centerY - (y + offset.y) * gridSpacing * scaleFactor
        };
      }

      function drawGrid() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const originX = centerX + offset.x * gridSpacing * scaleFactor;
        const originY = centerY - offset.y * gridSpacing * scaleFactor;
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 0.5;
        for (let x = originX; x <= width; x += gridSpacing * scaleFactor) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let x = originX; x >= 0; x -= gridSpacing * scaleFactor) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = originY; y <= height; y += gridSpacing * scaleFactor) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
        for (let y = originY; y >= 0; y -= gridSpacing * scaleFactor) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
        ctx.strokeStyle = '#707070';
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.moveTo(originX, 0);
        ctx.lineTo(originX, height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, originY);
        ctx.lineTo(width, originY);
        ctx.stroke();
      }

      function drawPolygon() {
        if (vertices.length > 0) {
          if (polygonComplete) {
            for (let i = 0; i < vertices.length; i++) {
              let v1 = vertices[i];
              let v2 = vertices[(i + 1) % vertices.length];
              let cp1 = toCanvasCoords(v1.x, v1.y);
              let cp2 = toCanvasCoords(v2.x, v2.y);
              ctx.beginPath();
              ctx.strokeStyle = (highlightIndex === i) ? 'red' : 'black';
              ctx.lineWidth = (highlightIndex === i) ? 4 : 2;
              ctx.moveTo(cp1.x, cp1.y);
              ctx.lineTo(cp2.x, cp2.y);
              ctx.stroke();
            }
            vertices.forEach(pt => {
              let cp = toCanvasCoords(pt.x, pt.y);
              ctx.fillStyle = 'red';
              ctx.beginPath();
              ctx.arc(cp.x, cp.y, 4, 0, 2 * Math.PI);
              ctx.fill();
            });
            if (!isPolygonConvex(vertices)) {
              ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
              ctx.beginPath();
              let start = toCanvasCoords(vertices[0].x, vertices[0].y);
              ctx.moveTo(start.x, start.y);
              for (let i = 1; i < vertices.length; i++) {
                let cp = toCanvasCoords(vertices[i].x, vertices[i].y);
                ctx.lineTo(cp.x, cp.y);
              }
              ctx.closePath();
              ctx.fill();
            }
          } else {
            ctx.beginPath();
            let start = toCanvasCoords(vertices[0].x, vertices[0].y);
            ctx.moveTo(start.x, start.y);
            for (let i = 1; i < vertices.length; i++) {
              let cp = toCanvasCoords(vertices[i].x, vertices[i].y);
              ctx.lineTo(cp.x, cp.y);
            }
            if (currentMouse) {
              let rubberbandEnd = toCanvasCoords(currentMouse.x, currentMouse.y);
              ctx.lineTo(rubberbandEnd.x, rubberbandEnd.y);
            }
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
            vertices.forEach(pt => {
              let cp = toCanvasCoords(pt.x, pt.y);
              ctx.fillStyle = 'red';
              ctx.beginPath();
              ctx.arc(cp.x, cp.y, 4, 0, 2 * Math.PI);
              ctx.fill();
            });
          }
        }
      }

      function drawAnalyticCenter() {
        if (analyticCenter != null) {
          let ac = toCanvasCoords(analyticCenter[0], analyticCenter[1]);
          ctx.fillStyle = 'black';
          ctx.beginPath();
          ctx.arc(ac.x, ac.y, 6, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      function drawObjective() {
        let target = null;
        if (objectiveVector != null) {
          target = objectiveVector;
        } else if (polygonComplete && objectiveVector === null && currentObjective != null) {
          target = currentObjective;
        }
        if (target != null) {
          let origin = toCanvasCoords(0, 0);
          let end = toCanvasCoords(target.x, target.y);
          ctx.strokeStyle = 'green';
          ctx.lineWidth = 3;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath();
          ctx.moveTo(origin.x, origin.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();
          let dx = end.x - origin.x, dy = end.y - origin.y;
          let angle = Math.atan2(dy, dx);
          let headLength = 10;
          let angle1 = angle + Math.PI / 6;
          let angle2 = angle - Math.PI / 6;
          let arrowX1 = end.x - headLength * Math.cos(angle1);
          let arrowY1 = end.y - headLength * Math.sin(angle1);
          let arrowX2 = end.x - headLength * Math.cos(angle2);
          let arrowY2 = end.y - headLength * Math.sin(angle2);
          ctx.beginPath();
          ctx.moveTo(end.x, end.y);
          ctx.lineTo(arrowX1, arrowY1);
          ctx.moveTo(end.x, end.y);
          ctx.lineTo(arrowX2, arrowY2);
          ctx.stroke();
        }
      }

      function drawCentralPath() {
        if (centralPath && centralPath.length > 0) {
          ctx.strokeStyle = 'purple';
          ctx.lineWidth = 2;
          ctx.beginPath();
          let start = toCanvasCoords(centralPath[0][0][0], centralPath[0][0][1]);
          ctx.moveTo(start.x, start.y);
          for (let i = 1; i < centralPath.length; i++) {
            let pt = toCanvasCoords(centralPath[i][0][0], centralPath[i][0][1]);
            ctx.lineTo(pt.x, pt.y);
          }
          ctx.stroke();
          centralPath.forEach((pt, i) => {
            let cp = toCanvasCoords(pt[0][0], pt[0][1]);
            ctx.beginPath();
            ctx.fillStyle = (highlightCentralPathIndex === i) ? 'green' : 'purple';
            ctx.arc(cp.x, cp.y, (highlightCentralPathIndex === i) ? 5 : 3, 0, 2 * Math.PI);
            ctx.fill();
          });
        }
      }

      function draw() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        ctx.clearRect(0, 0, width, height);
        drawGrid();
        drawPolygon();
        drawAnalyticCenter();
        drawObjective();
        drawCentralPath();
      }

      function isPointInsidePolygon(point, poly) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          let xi = poly[i].x, yi = poly[i].y;
          let xj = poly[j].x, yj = poly[j].y;
          let intersect = ((yi > point.y) !== (yj > point.y)) &&
            (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      let draggingPointIndex = null;
      let draggingObjective = false;
      canvas.addEventListener('mousedown', function (event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const logicalMouse = toLogicalCoords(mouseX, mouseY);
        for (let i = 0; i < vertices.length; i++) {
          if (distance(logicalMouse, vertices[i]) < 0.5) {
            draggingPointIndex = i;
            return;
          }
        }
        if (polygonComplete && objectiveVector !== null) {
          const tip = toCanvasCoords(objectiveVector.x, objectiveVector.y);
          if (pixelDistance({ x: mouseX, y: mouseY }, tip) < 10) {
            draggingObjective = true;
            return;
          }
        }
      });

      canvas.addEventListener('mousemove', function (event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        if (draggingPointIndex !== null) {
          vertices[draggingPointIndex] = toLogicalCoords(mouseX, mouseY);
          draw();
          return;
        }
        if (draggingObjective) {
          objectiveVector = toLogicalCoords(mouseX, mouseY);
          updateObjectiveDisplay();
          draw();
          return;
        }
        if (!polygonComplete) {
          currentMouse = toLogicalCoords(mouseX, mouseY);
          draw();
        } else if (polygonComplete && objectiveVector === null) {
          currentObjective = toLogicalCoords(mouseX, mouseY);
          draw();
        }
      });

      canvas.addEventListener('mouseup', function () {
        if (draggingPointIndex !== null) {
          saveState();
          draggingPointIndex = null;
          sendPolytope();
        }
        if (draggingObjective) {
          saveState();
          draggingObjective = false;
          sendPolytope();
        }
      });

      canvas.addEventListener('dblclick', function (event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const logicalMouse = toLogicalCoords(mouseX, mouseY);
        for (let i = 0; i < vertices.length; i++) {
          let v1 = vertices[i];
          let v2 = vertices[(i + 1) % vertices.length];
          if (isPointNearLine(logicalMouse, v1, v2)) {
            let dx = v2.x - v1.x;
            let dy = v2.y - v1.y;
            let length = Math.sqrt(dx * dx + dy * dy);
            let normal = { x: -dy / length, y: dx / length };
            let adjustmentFactor = 0.1;
            const newPoint = {
              x: logicalMouse.x - normal.x * adjustmentFactor,
              y: logicalMouse.y - normal.y * adjustmentFactor
            };
            saveState();
            vertices.splice(i + 1, 0, newPoint);
            updateSidebarUI();
            draw();
            sendPolytope();
            break;
          }
        }
      });

      function isPointNearLine(point, v1, v2) {
        const dist = Math.abs((v2.y - v1.y) * point.x - (v2.x - v1.x) * point.y + v2.x * v1.y - v2.y * v1.x) /
          Math.sqrt((v2.y - v1.y) ** 2 + (v2.x - v1.x) ** 2);
        return dist < 0.5;
      }

      canvas.addEventListener('click', function (event) {
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;
        let pt = toLogicalCoords(clickX, clickY);
        if (!polygonComplete) {
          if (vertices.length >= 3) {
            const closeThreshold = 0.5;
            if (distance(pt, vertices[0]) < closeThreshold) {
              polygonComplete = true;
              interiorPoint = computeCentroid(vertices);
              updateSidebarUI();
              draw();
              sendPolytope();
              return;
            }
            if (isPointInsidePolygon(pt, vertices)) {
              polygonComplete = true;
              interiorPoint = pt;
              updateSidebarUI();
              draw();
              sendPolytope();
              return;
            }
          }
          let tentative = vertices.slice();
          tentative.push(pt);
          if (tentative.length >= 3 && !isPolygonConvex(tentative)) {
            alert("Adding this vertex would make the polygon nonconvex. Please choose another point.");
            return;
          }
          saveState();
          vertices.push(pt);
          updateSidebarUI();
          draw();
          sendPolytope();
        } else if (polygonComplete && objectiveVector === null) {
          saveState();
          objectiveVector = currentObjective ? currentObjective : pt;
          updateObjectiveDisplay();
          draw();
          return;
        }
      });

      function isPolygonConvex(pts) {
        if (pts.length < 3) return true;
        let n = pts.length;
        let prevCross = 0;
        for (let i = 0; i < n; i++) {
          let p0 = pts[i];
          let p1 = pts[(i + 1) % n];
          let p2 = pts[(i + 2) % n];
          let dx1 = p1.x - p0.x, dy1 = p1.y - p0.y;
          let dx2 = p2.x - p1.x, dy2 = p2.y - p1.y;
          let cross = dx1 * dy2 - dy1 * dx2;
          if (cross !== 0) {
            if (prevCross === 0) prevCross = cross;
            else if (Math.sign(cross) !== Math.sign(prevCross)) return false;
          }
        }
        return true;
      }
      function sendPolytope() {
        const data = {
          points: vertices.map(pt => [pt.x, pt.y]),
          interior: interiorPoint ? [interiorPoint.x, interiorPoint.y] : null
        };
        fetch('/polytope', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        })
          .then(response => response.json())
          .then(result => {
            if (result.inequalities) {
              let html = "";
              if (!isPolygonConvex(vertices)) {
                inequalitiesDiv.innerHTML = "Nonconvex";
                return;
              }
              result.inequalities.forEach((ineq, index) => {
                html += `<div class="inequality-item" data-index="${index}">
                         ${ineq}<br>
                         <span class="barrier-weight-container" style="display: none;">
                           <span style="font-family: sans-serif;">Barrier weight:</span>
                           <input type="number" id="weight-${index}" value="1" step="any" style="width:60px" />
                         </span>
                       </div>`;
              });
              inequalitiesDiv.innerHTML = html;
              document.querySelectorAll('.inequality-item').forEach(item => {
                item.addEventListener('mouseenter', function () {
                  highlightIndex = parseInt(this.getAttribute('data-index'));
                  draw();
                });
                item.addEventListener('mouseleave', function () {
                  highlightIndex = null;
                  draw();
                });
              });
            } else {
              inequalitiesDiv.textContent = "No inequalities returned.";
            }
            computedVertices = result.vertices;
            computedLines = result.lines;
            if (centralPathComputed && objectiveVector != null && computedLines && computedLines.length > 0) {
              computeCentralPath();
            }
          })
          .catch(error => {
            console.error('Error:', error);
            inequalitiesDiv.textContent = "Error computing inequalities.";
          });
      }

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
    </script>
    <div id="sidebarHandle"></div>
    <script>
      const sidebar = document.getElementById('sidebar');
      const handle = document.getElementById('sidebarHandle');

      let isResizing = false;

      handle.addEventListener('mousedown', function (e) {
        isResizing = true;
        e.preventDefault();
      });

      document.addEventListener('mousemove', function (e) {
        if (!isResizing) return;
        let newWidth = e.clientX;
        if (newWidth < 200) newWidth = 200;
        if (newWidth > 600) newWidth = 600;
        sidebar.style.width = newWidth + 'px';
        handle.style.left = newWidth + 'px';
        updateCenter();
        draw();
      });

      document.addEventListener('mouseup', function (e) {
        if (isResizing) {
          isResizing = false;
        }
      });

      let barrierWeightsVisible = false;
      const toggleBarrierWeightsButton = document.getElementById('toggleBarrierWeightsButton');
      toggleBarrierWeightsButton.addEventListener('click', function() {
        barrierWeightsVisible = !barrierWeightsVisible;
        const containers = document.querySelectorAll('.barrier-weight-container');
        containers.forEach(container => {
          container.style.display = barrierWeightsVisible ? "inline" : "none";
        });
        toggleBarrierWeightsButton.textContent = barrierWeightsVisible ? "Hide Barrier Weights" : "Show Barrier Weights";
      });
    </script>
  </body>
</html>
