<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Primal-Dual Hybrid Gradient (PDHG) - lpviz Documentation</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
        },
        svg: {
          fontCache: "global",
        },
      };
    </script>
    <link rel="stylesheet" href="docs.css" />
  </head>
  <body>
    <div class="navigation">
      <strong>lpviz Documentation</strong> | <a href="./">← Back to Documentation</a> |
      <a href="../">← Back to lpviz</a>
    </div>

    <h1>Primal-Dual Hybrid Gradient (PDHG)</h1>

    <div class="info"><strong>Overview:</strong> PDHG is a first-order method that alternates between primal and dual updates. It's particularly effective for large-scale problems and offers both equality-constrained (standard form) and inequality-constrained modes.</div>

    <h2>Problem Setup</h2>

    <p>PDHG in lpviz handles the user's problem from the frontend form:</p>

    <div class="equation-block">$$\begin{align} \max_x \quad & c^\top x \\ \text{s.t.} \quad & Ax \leq b \end{align}$$</div>

    <p>The algorithm provides two modes depending on how constraints are handled:</p>

    <div class="mode-section">
      <h3>Mode Selection</h3>

      <div class="code-math-container">
        <div class="code-section">
          <h4>
            Code: Mode Selection
            <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/pdhg.ts#L26-L30" target="_blank">lines 26-30</a></span>
          </h4>
          <div class="code-line"><span class="code-keyword">if</span> (ineq) {</div>
          <div class="code-line code-indent-1">
            <span class="code-keyword">return</span>
            <span class="code-function">pdhgIneq</span>(lines, objective, solverOptions);
          </div>
          <div class="code-line">} <span class="code-keyword">else</span> {</div>
          <div class="code-line code-indent-1">
            <span class="code-keyword">return</span>
            <span class="code-function">pdhgEq</span>(lines, objective, solverOptions);
          </div>
          <div class="code-line">}</div>
        </div>
        <div class="math-section">
          <h4>Mathematical Interpretation</h4>
          <p><strong>Inequality Mode:</strong> Works directly with $Ax \leq b$</p>
          <p><strong>Standard Form Mode:</strong> Converts to equality constraints:</p>
          $$Ax \leq b \quad \Rightarrow \quad Ax + s = b, \quad s \geq 0$$
          <p>Variables split as $x = x^+ - x^-$ with $x^+, x^- \geq 0$</p>
        </div>
      </div>
    </div>

    <h2>Standard Form PDHG</h2>

    <div class="algorithm-box">
      <h3>Equality-Constrained Formulation</h3>
      <p>Standard PDHG solves problems of the form: $\min_x c^\top x$ subject to $Ax = b$, $x \geq 0$.</p>
    </div>

    <h3>Algorithm Updates</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Standard PDHG Updates
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/pdhg_eq.ts#L74-L78" target="_blank">lines 74-78</a></span>
        </h4>
        <div class="code-line">
          <span class="code-comment">// x_{k+1} = [x_k - η(c + A^T y_k)]_+</span>
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">xk_plus_1</span> = <span class="code-function">projectNonNegative</span>(Matrix.sub(xk, Matrix.add(c, A.transpose().mmul(yk)).mul(eta)));
        </div>
        <div class="code-line">
          <span class="code-comment">// x̃_k = x_{k+1} + (x_{k+1} - x_k)</span>
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">x_extrapolated</span> = Matrix.add(xk_plus_1, Matrix.sub(xk_plus_1, xk));
        </div>
        <div class="code-line">
          <span class="code-comment">// y_{k+1} = y_k + τ(Ax̃_k - b)</span>
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">yk_plus_1</span> = Matrix.add(yk, Matrix.sub(A.mmul(x_extrapolated), b).mul(tau));
        </div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>The PDHG updates are:</p>
        $$x^{k+1} = \Pi_{\geq 0}(x^k - \eta(c + A^\top y^k))$$ $$\tilde{x}^{k+1} = 2x^{k+1} - x^k$$ $$y^{k+1} = y^k + \tau(A\tilde{x}^{k+1} - b)$$
        <p>where $\Pi_{\geq 0}$ is projection onto non-negative orthant and $\tilde{x}^{k+1}$ is the extrapolated primal variable.</p>
      </div>
    </div>

    <h3>Convergence Criterion</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Standard Form Convergence
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/pdhg_eq.ts#L17-L30" target="_blank">lines 17-30</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">Ax</span> = A.mmul(xk);
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">primalFeasibility</span> =
        </div>
        <div class="code-line">Matrix.sub(Ax, b).norm() / (1 + b.norm());</div>
        <div class="code-line"></div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">ATy</span> = A.transpose().mmul(yk);
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">negATy_minus_c</span> = Matrix.sub(ATy.mul(-1), c);
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">dualFeasibility</span> =
        </div>
        <div class="code-line"><span class="code-function">projectNonNegative</span>(negATy_minus_c).norm() /</div>
        <div class="code-line">(1 + c.norm());</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>Three components measure convergence:</p>
        <p><strong>Primal feasibility:</strong> $\frac{\|Ax - b\|}{1 + \|b\|}$</p>
        <p><strong>Dual feasibility:</strong> $\frac{\|\Pi_{\geq 0}(-A^\top y - c)\|}{1 + \|c\|}$</p>
        <p><strong>Duality gap:</strong> $\frac{|c^\top x + b^\top y|}{1 + |c^\top x| + |b^\top y|}$</p>
      </div>
    </div>

    <h2>Inequality Form PDHG</h2>

    <div class="algorithm-box">
      <h3>Direct Inequality Handling</h3>
      <p>Inequality mode avoids transforming constraints, working directly with the original problem structure.</p>
    </div>

    <h3>Algorithm Updates</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Inequality PDHG Updates
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/pdhg_ineq.ts#L69-L73" target="_blank">lines 69-73</a></span>
        </h4>
        <div class="code-line">
          <span class="code-comment">// y update (dual first)</span>
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">yk_plus_1</span> = <span class="code-function">projectNonNegative</span>(
        </div>
        <div class="code-line code-indent-1">Matrix.add(yk, Matrix.sub(A.mmul(xk), b).mul(tau))</div>
        <div class="code-line">);</div>
        <div class="code-line">
          <span class="code-comment">// x update with extrapolated dual</span>
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">y_extrapolated</span> = Matrix.add(yk_plus_1,
        </div>
        <div class="code-line code-indent-1">Matrix.sub(yk_plus_1, yk));</div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">xk_plus_1</span> = Matrix.sub(xk,
        </div>
        <div class="code-line code-indent-1">Matrix.add(c, A.transpose().mmul(y_extrapolated)).mul(eta));</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>The inequality-mode updates are:</p>
        $$y^{k+1} = \Pi_{\geq 0}(y^k + \tau(Ax^k - b))$$ $$\tilde{y}^{k+1} = 2y^{k+1} - y^k$$ $$x^{k+1} = x^k - \eta(c + A^\top \tilde{y}^{k+1})$$
        <p>Note: Dual variables $y \geq 0$ due to inequality constraints, and extrapolation is applied to dual variables instead of primal.</p>
      </div>
    </div>

    <h3>Convergence Criterion</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Inequality Form Convergence
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/pdhg_ineq.ts#L17-L26" target="_blank">lines 17-26</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">Ax</span> = A.mmul(xk);
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">primalFeasibility</span> =
        </div>
        <div class="code-line"><span class="code-function">projectNonNegative</span>(Matrix.sub(Ax, b)).norm() /</div>
        <div class="code-line">(1 + b.norm());</div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">dualFeasibility</span> =
        </div>
        <div class="code-line"><span class="code-function">projectNonNegative</span>(yk.mul(-1)).norm() /</div>
        <div class="code-line">(1 + c.norm());</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>For inequality constraints:</p>
        <p><strong>Primal feasibility:</strong> $\frac{\|\Pi_{\geq 0}(Ax - b)\|}{1 + \|b\|}$</p>
        <p><strong>Dual feasibility:</strong> $\frac{\|\Pi_{\geq 0}(-y)\|}{1 + \|c\|}$</p>
        <p>The projection $\Pi_{\geq 0}(Ax - b)$ measures constraint violation.</p>
      </div>
    </div>

    <h2>Step Size Selection</h2>

    <div class="definition-box">
      <h3>Convergence Theory</h3>
      <p>PDHG converges when the step sizes satisfy:</p>
      <div class="equation-block">$$\eta \tau \|A\|^2 &lt; 1$$</div>
      <p>where $\|A\|$ is the spectral norm of matrix $A$. In practice, $\eta = \tau = 0.25$ often works well.</p>
    </div>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Default Parameters
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/pdhg.ts#L16-L22" target="_blank">lines 16-22</a></span>
        </h4>
        <div class="code-line"><span class="code-keyword">const</span> {</div>
        <div class="code-line">ineq = false,</div>
        <div class="code-line">maxit = 1000,</div>
        <div class="code-line"><span class="code-variable">eta</span> = 0.25,</div>
        <div class="code-line"><span class="code-variable">tau</span> = 0.25,</div>
        <div class="code-line">verbose = false,</div>
        <div class="code-line">tol = 1e-4,</div>
        <div class="code-line">} = options;</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>Default step sizes $\eta = \tau = 0.25$ ensure:</p>
        $$\eta \tau = 0.0625 &lt; \frac{1}{\|A\|^2}$$
        <p>for most well-conditioned problems. For ill-conditioned problems, smaller step sizes may be needed.</p>
      </div>
    </div>

    <h2>Variable Recovery</h2>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Solution Reconstruction
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/pdhg_eq.ts#L101-L106" target="_blank">lines 101-106</a></span>
        </h4>
        <div class="code-line">
          <span class="code-comment">// Reconstruct x = x+ - x-</span>
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">x_iterates</span> = chi_iterates.map((chi_k: Vec2N) => {
        </div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">x_plus</span> = Matrix.columnVector(
        </div>
        <div class="code-line code-indent-2">chi_k.slice(0, n_orig));</div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">x_minus</span> = Matrix.columnVector(
        </div>
        <div class="code-line code-indent-2">chi_k.slice(n_orig, 2 * n_orig));</div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">return</span>
          x_plus.sub(x_minus).to1DArray();
        </div>
        <div class="code-line">});</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>In standard form mode, variables are split:</p>
        $$x = x^+ - x^-, \quad x^+, x^- \geq 0$$
        <p>The final solution reconstructs the original variables from their positive and negative parts.</p>
      </div>
    </div>

    <h2>Key Features</h2>

    <div class="algorithm-box">
      <h3>Saddle Point Interpretation</h3>
      <p>PDHG solves the saddle point problem:</p>
      <div class="equation-block">$$\min_x \max_y \quad c^\top x + y^\top(Ax - b) - \delta_{\geq 0}(x) - \delta_{\geq 0}(y)$$</div>
      <p>where $\delta_{\geq 0}$ is the indicator function of the non-negative orthant. The alternating updates correspond to approximate gradient ascent in $y$ and gradient descent in $x$.</p>
    </div>

    <div class="navigation">
      <a href="./">← Back to Documentation</a> |
      <a href="../">← Back to lpviz</a>
    </div>
  </body>
</html>
