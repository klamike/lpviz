<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Central Path Method - lpviz Documentation</title>
    <link rel="canonical" href="https://lpviz.net/docs/central-path.html" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
        },
        svg: {
          fontCache: "global",
        },
      };
    </script>
    <link rel="stylesheet" href="docs.css" />
  </head>
  <body>
    <div class="navigation">
      <strong>lpviz Documentation</strong> | <a href="./">← Back to Documentation</a> |
      <a href="../">← Back to lpviz</a>
    </div>

    <h1>Central Path Method</h1>

    <div class="info"><strong>Overview:</strong> The Central Path method computes a sequence of points that approach the optimal solution by following the central path of the barrier problem. Each point is found using Newton's method with line search.</div>

    <h2>Barrier Problem Formulation</h2>

    <p>The central path method transforms the linear program:</p>

    <div class="equation-block">$$\begin{align} \max_x \quad & c^\top x \\ \text{s.t.} \quad & Ax \leq b \end{align}$$</div>

    <p>Into a sequence of barrier problems:</p>

    <div class="equation-block">$$x(\mu) = \arg\min_x \left\{ c^\top x - \mu \sum_{i=1}^m \log(b_i - a_i^\top x) \right\}$$</div>

    <div class="definition-box">
      <h3>Central Path</h3>
      <p>The central path $\{x(\mu) : \mu > 0\}$ is a smooth curve of minimizers of the barrier problem. As $\mu \to 0^+$, the path converges to the optimal solution of the original linear program.</p>
    </div>

    <h2>Barrier Parameter Sequence</h2>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Barrier Parameters
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/centralPath.ts#L213-L227" target="_blank">lines 213-227</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">function</span>
          <span class="code-function">centralPathMu</span>(niter: number) {
        </div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">barrierParameters</span> = [];
        </div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">startVal</span> = BARRIER_PARAM_START;
        </div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">stopVal</span> = BARRIER_PARAM_END;
        </div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">stepSize</span> = (stopVal - startVal) / (niter - 1);
        </div>
        <div class="code-line code-indent-1"><span class="code-keyword">for</span> (let i = 0; i &lt; niter; i++) {</div>
        <div class="code-line code-indent-2">barrierParameters.push(10.0 ** (startVal + i * stepSize));</div>
        <div class="code-line code-indent-1">}</div>
        <div class="code-line code-indent-1"><span class="code-keyword">return</span> barrierParameters;</div>
        <div class="code-line">}</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>The barrier parameter sequence is logarithmically spaced:</p>
        $$\mu_k = 10^{3 - 8k/(n-1)}, \quad k = 0, 1, \ldots, n-1$$
        <p>This gives:</p>
        $$\mu_0 = 10^3 = 1000, \quad \mu_{n-1} = 10^{-5} = 0.00001$$
        <p>The sequence decreases geometrically toward zero.</p>
      </div>
    </div>

    <h2>Newton's Method for Each Barrier Problem</h2>

    <div class="barrier-section">
      <h3>Single Point Computation</h3>
      <p>For each $\mu_k$, Newton's method solves the barrier problem to find $x(\mu_k)$.</p>
    </div>

    <h3>Objective Function</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Barrier Function
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/centralPath.ts#L95-L102" target="_blank">lines 95-102</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">function</span>
          <span class="code-function">calculateObjective</span>(point: VectorN) {
        </div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">constraintResiduals</span> = Amatrix.mmul(point);
        </div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">slackVariables</span> = Matrix.sub(bVec, constraintResiduals);
        </div>
        <div class="code-line code-indent-1"><span class="code-keyword">if</span> (slackVariables.min() &lt;= 0) {</div>
        <div class="code-line code-indent-2"><span class="code-keyword">return</span> -Infinity;</div>
        <div class="code-line code-indent-1">}</div>
        <div class="code-line code-indent-1"><span class="code-keyword">return</span> cVec.dot(point) + mu * slackVariables.log().sum();</div>
        <div class="code-line">}</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>The barrier objective function is:</p>
        $$f_\mu(x) = c^\top x - \mu \sum_{i=1}^m \log(b_i - a_i^\top x)$$
        <p>The residual vector $r = b - Ax$ represents constraint slack. The logarithmic barrier ensures $x$ stays strictly feasible: $Ax &lt; b$.</p>
      </div>
    </div>

    <h3>Gradient Computation</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Gradient
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/centralPath.ts#L38-L39" target="_blank">lines 38-39</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">inverseSlack</span> = Matrix.pow(slackVariables, -1);
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">gradient</span> = Matrix.sub(cVec, Amatrix.transpose().mmul(inverseSlack).mul(mu));
        </div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>The gradient of the barrier function is:</p>
        $$\nabla f_\mu(x) = c - \mu A^\top \frac{1}{b - Ax}$$
        <p>where $\frac{1}{b - Ax}$ denotes element-wise reciprocal. As constraints become active ($a_i^\top x \to b_i$), the corresponding gradient components grow large, repelling $x$ from the boundary.</p>
      </div>
    </div>

    <h3>Hessian Computation</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Hessian
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/centralPath.ts#L42-L46" target="_blank">lines 42-46</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">inverseSlackSquared</span> = Matrix.pow(inverseSlack, 2);
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">hessian</span> = Amatrix.transpose()
        </div>
        <div class="code-line code-indent-1">.mmul(<span class="code-function">diag</span>(inverseSlackSquared))</div>
        <div class="code-line code-indent-1">.mmul(Amatrix)</div>
        <div class="code-line code-indent-1">.mul(mu);</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>The Hessian of the barrier function is:</p>
        $$\nabla^2 f_\mu(x) = \mu A^\top \text{diag}\left(\frac{1}{(b - Ax)^2}\right) A$$
        <p>The Hessian is positive definite for strictly feasible $x$, ensuring the barrier function is strictly convex.</p>
      </div>
    </div>

    <h3>Newton Step</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Newton Direction
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/centralPath.ts#L48" target="_blank">line 48</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">return</span>
          <span class="code-function">solve</span>(hessian, gradient);
        </div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>The Newton direction solves:</p>
        $$\nabla^2 f_\mu(x^k) \Delta x = -\nabla f_\mu(x^k)$$
        <p>This gives the direction of steepest descent in the Newton metric defined by the Hessian.</p>
      </div>
    </div>

    <h2>Line Search</h2>

    <div class="algorithm-box">
      <h3>Two-Stage Line Search</h3>
      <p>The algorithm uses a two-stage approach: first ensure feasibility, then apply Armijo rule for sufficient decrease.</p>
    </div>

    <h3>Stage 1: Feasibility Line Search</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Domain Line Search
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/centralPath.ts#L63-L87" target="_blank">lines 63-87</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">let</span>
          <span class="code-variable">alpha</span> = 1.0;
        </div>
        <div class="code-line"><span class="code-keyword">while</span> (true) {</div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">xNew</span> = Matrix.add(x, Matrix.mul(dx, alpha));
        </div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">rNew</span> = Matrix.sub(bVec, Amatrix.mmul(xNew));
        </div>
        <div class="code-line code-indent-1"><span class="code-keyword">if</span> (rNew.min() > 1e-12) <span class="code-keyword">break</span>;</div>
        <div class="code-line code-indent-1">alpha *= 0.5;</div>
        <div class="code-line code-indent-1"><span class="code-keyword">if</span> (alpha &lt; 1e-10) {</div>
        <div class="code-line code-indent-2">
          <span class="code-keyword">return</span> null;
          <span class="code-comment">// Step too small</span>
        </div>
        <div class="code-line code-indent-1">}</div>
        <div class="code-line">}</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>Find largest $\alpha$ such that $x + \alpha \Delta x$ remains strictly feasible:</p>
        $$A(x + \alpha \Delta x) &lt; b$$
        <p>This ensures the logarithmic barrier remains well-defined. The step size is repeatedly halved until feasibility is achieved.</p>
      </div>
    </div>

    <h3>Stage 2: Armijo Line Search</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Armijo Condition
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/centralPath.ts#L55-L87" target="_blank">lines 55-87</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">t</span> = 0.5;
          <span class="code-comment">// Shrink factor</span>
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">beta</span> = 0.01;
          <span class="code-comment">// Sufficient decrease</span>
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">gradDotDx</span> = grad.dot(dx);
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">fx</span> = <span class="code-function">calculateObjective</span>(x);
        </div>
        <div class="code-line"></div>
        <div class="code-line"><span class="code-keyword">while</span> (true) {</div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">fxNew</span> = <span class="code-function">calculateObjective</span>(xNew);
        </div>
        <div class="code-line code-indent-1"><span class="code-keyword">if</span> (fxNew >= fx + beta * alpha * gradDotDx) <span class="code-keyword">break</span>;</div>
        <div class="code-line code-indent-1">alpha *= t;</div>
        <div class="code-line">}</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>The Armijo condition requires sufficient decrease:</p>
        $$f_\mu(x + \alpha \Delta x) \leq f_\mu(x) + \beta \alpha \nabla f_\mu(x)^\top \Delta x$$
        <p>where $\beta = 0.01$ is small. This ensures the step makes meaningful progress toward the minimum.</p>
      </div>
    </div>

    <h2>Convergence and Path Following</h2>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Newton Convergence
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/centralPath.ts#L133-L136" target="_blank">lines 133-136</a></span>
        </h4>
        <div class="code-line"><span class="code-keyword">if</span> (gradient.max() &lt; epsilon) {</div>
        <div class="code-line code-indent-1"><span class="code-keyword">if</span> (verbose) console.log("Converged in " + iteration +</div>
        <div class="code-line code-indent-2">" iterations with mu = " + mu);</div>
        <div class="code-line code-indent-1"><span class="code-keyword">return</span> currentPoint;</div>
        <div class="code-line">}</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>Newton's method converges when:</p>
        $$\|\nabla f_\mu(x)\|_\infty &lt; \epsilon$$
        <p>This indicates $x \approx x(\mu)$, the minimizer of the barrier problem for parameter $\mu$.</p>
      </div>
    </div>

    <h3>Warm Starting</h3>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Path Continuation
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/centralPath.ts#L170-L202" target="_blank">lines 170-202</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">let</span>
          <span class="code-variable">currentPoint</span> = Matrix.columnVector(<span class="code-function">centroid</span>(vertices));
        </div>
        <div class="code-line"></div>
        <div class="code-line"><span class="code-keyword">for</span> (const currentMu of barrierParameters) {</div>
        <div class="code-line code-indent-1">
          <span class="code-keyword">const</span>
          <span class="code-variable">optimalPoint</span> = <span class="code-function">centralPathXk</span>(A, b, objectiveVector,
        </div>
        <div class="code-line code-indent-2">currentMu, currentPoint, opts);</div>
        <div class="code-line code-indent-1"><span class="code-keyword">if</span> (optimalPoint !== null) {</div>
        <div class="code-line code-indent-2">centralPathPoints.push(pathPoint);</div>
        <div class="code-line code-indent-2">
          currentPoint = optimalPoint;
          <span class="code-comment">// Warm start</span>
        </div>
        <div class="code-line code-indent-1">}</div>
        <div class="code-line">}</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>The algorithm uses <strong>warm starting</strong>:</p>
        <ul>
          <li>Initialize with centroid of feasible region vertices</li>
          <li>Use $x(\mu_k)$ as starting point for computing $x(\mu_{k+1})$</li>
          <li>Exploits smoothness of central path for faster convergence</li>
        </ul>
      </div>
    </div>

    <h2>Solution Trajectory</h2>

    <div class="code-math-container">
      <div class="code-section">
        <h4>
          Code: Extended Points
          <span class="line-ref"><a href="https://github.com/klamike/lpviz/blob/main/lpviz/src/algorithms/centralPath.ts#L182-L187" target="_blank">lines 182-187</a></span>
        </h4>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">linearObjective</span> = objectiveVector.dot(optimalPoint);
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">barrierTerm</span> = currentMu * slackVariables.log().sum();
        </div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">totalObjective</span> = linearObjective + barrierTerm;
        </div>
        <div class="code-line"></div>
        <div class="code-line">
          <span class="code-keyword">const</span>
          <span class="code-variable">pathPoint</span> = [...optimalPoint.to1DArray(), totalObjective];
        </div>
        <div class="code-line">centralPathPoints.push(pathPoint);</div>
      </div>
      <div class="math-section">
        <h4>Mathematical Interpretation</h4>
        <p>Each point on the central path includes:</p>
        <ul>
          <li><strong>Primal variables:</strong> $x(\mu)$</li>
          <li><strong>Barrier objective:</strong> $c^\top x(\mu) - \mu \sum_i \log(b_i - a_i^\top x(\mu))$</li>
        </ul>
        <p>In 3D visualization, the z-coordinate shows the barrier objective evolution.</p>
      </div>
    </div>

    <div class="navigation">
      <a href="./">← Back to Documentation</a> |
      <a href="../">← Back to lpviz</a>
    </div>
  </body>
</html>
